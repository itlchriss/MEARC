package g0801_0900.s0879_profitable_schemes;

// #Hard #Array #Dynamic_Programming #2022_03_28_Time_80_ms_(43.42%)_Space_42.9_MB_(71.71%)

public class Solution {
//@ ensures(*Preconditions:*);
//@ ensures(*The input integer `n` represents the number of members in the group.*);
//@ ensures(*The input integer `minProfit` represents the minimum profit required for a scheme to be considered profitable.*);
//@ ensures(*The input array `group` represents the number of members required for each crime.*);
//@ ensures(*The input array `profit` represents the profit generated by each crime.*);
//@ ensures(*The length of the `group` array is equal to the length of the `profit` array.*);
//@ ensures(*The length of the `group` array is greater than or equal to 1.*);
//@ ensures(*The length of the `group` array is less than or equal to 100.*);
//@ ensures(*Each element in the `group` array is an integer between 1 and 100.*);
//@ ensures(*Each element in the `profit` array is an integer between 0 and 100.*);
//@ ensures(**);
//@ ensures(*Postconditions:*);
//@ ensures(*The method returns an integer representing the number of profitable schemes that can be chosen.*);
//@ ensures(*The returned value is modulo 10^9 + 7.*);
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        long[][] dp = new long[n + 1][minProfit + 1];
        long modulus = 1000000007L;
        for (int i = 0; i < dp.length; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i < group.length; i++) {
            int currWorker = group[i];
            int currProfit = profit[i];
            for (int j = dp.length - 1; j >= currWorker; j--) {
                for (int k = dp[j].length - 1; k >= 0; k--) {
                    dp[j][k] =
                            (dp[j][k] + dp[j - currWorker][Math.max((k - currProfit), 0)])
                                    % modulus;
                }
            }
        }
        return (int) dp[n][minProfit];
    }
}